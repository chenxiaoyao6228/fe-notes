# GUI绘图基础

## 立即模式与保留模式

图形 API 可以分为 保留模式(Retained mode) API 和 即时模式 API(Immediate Mode)。 

### 保留模式

![](https://learn.microsoft.com/zh-cn/windows/win32/learnwin32/images/graphics06.png)

**该模式几乎应用于所有的GUI系统中， 如HTML DOM、Windows、Apple UIKit**。

保留模式 API 是声明性的。 应用程序从图形基元（如形状和线条）构造场景。 图形库将场景的模型存储在内存中。 若要绘制框架，图形库会将场景转换为一组绘图命令。 在帧之间，图形库将场景保留在内存中。 若要更改呈现的内容，应用程序会发出命令来更新场景，例如添加或删除形状。 然后，该库负责重绘场景。

这种模式的GUI存在的问题是：

- 必须编写大量代码来管理GUI对象的创建和销毁。

- 设想你有一个滚动列表，你经常需要创建100多个或1000多个GUI控件（就像HTML，创建一个TR，然后是TD，然后是每个TD的内容，等等）。如果数据真的很大，你最终不得不创建一些控件的虚拟窗口，要么在用户滚动时创建新的窗口并且删除旧窗口，要么将旧窗口从后面拉出来，然后将其添加到前面。其结果是：你需要写的代码太多了。

- 创建和销毁对象导致UI反应迟缓。由于GUI对象的创建和销毁速度很慢（通常它们是非常大的对象），因此通常需要编写大量的代码来帮助寻找和设计解决方案，以最小化需要创建和销毁的对象数量。想想React如何使用虚拟DOM来识别差异，然后将这些差异应用到实际的GUI控件和DOM树/场景图中。

- 你必须编制数据传入/传出控件。这就需要先将数据复制到控件中，然后对事件做出响应，并将控件中的新数据读回。需要编写更多的代码。

### 立即模式

![](https://learn.microsoft.com/zh-cn/windows/win32/learnwin32/images/graphics07.png)


即时模式 API 是过程性的，每次绘制新框架时，应用程序都会直接发出绘图命令，图形库不会在帧之间存储场景模型。其优点是：

- 不需要分配内存，不需要对必须管理的对象进行创建和销毁操作，没有状态，也不需要注册或响应的事件或回调

- 速度很快。 即使使用非常复杂的UI并且只有单线程的情况下。

**绝大多数游戏是这类模式，我们的Canvas API也属于此类**

但这也就意味着一旦图形绘制到canvas之中，我们就无法对画布的图形进行修改了，唯一的方式就是重绘。因此我们的canvas应用中都会有一个draw或者paint函数, 每次绘制的时候首先要清理画布，然后再进行绘制。
```js
draw(ctx){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}
```
要说缺点嘛，就是某些东西在canvas中实现比较麻烦，比如说"事件系统"。我们不能像在 dom 元素上监听事件一样,在 canvas 所渲染的图形内绑定各种事件, 因此基于 canvas 画布开发出一套交互式应用是件复杂的事情。

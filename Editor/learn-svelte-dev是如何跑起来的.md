## 前言

在研究 webContainer api 的时候发现官网案例里面有 svelte, 里面提到了 svelte 作者 rich 的一个演讲[Full Stack Documentation – Rich Harris, JSNation 2022](https://www.youtube.com/watch?v=RwBolXX9Pis),

顺藤摸瓜找到了 Github 地址: https://github.com/sveltejs/learn.svelte.dev/tree/main, 拉下仓库研究一下是如何使用 webContainer 的.

## 准备

拉完仓库后用 yarn 安装

> error This project's package.json defines "packageManager": "yarn@pnpm@8.15.1". However the current global version of Yarn is 1.22.22.

发现一个用法细节, 在 package.json 中可以指定默认的包管理工具以及依赖的版本, 又学到了.

```json
{
  "packageManager": "pnpm@8.15.1"
}
```

添加 vscode 断点配置

```json
// launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Attach to Svelte App",
      "type": "chrome",
      "request": "launch",
      "url": "http://127.0.0.1:5173/tutorial/welcome-to-svelte",
      "skipFiles": ["<node_internals>/**"]
    }
  ]
}
```

直接启动 dev 访问后报路由不存在, 看了下 README 才发现, 有提前的步骤需要跑

```sh
node scripts/create-common-bundle
pnpm dev
```

那`create-common-bundle`干了什么呢?

TODO:

打出来的 zip 包可以显著减少请求, 一个想到的场景就是, 如果一些编辑器需要提供一些固定的模板的时候, 直接把对应的模板代码+ node_modules 达成一个 zip 包就可以了, 减少了下载的过程.

## client/adapters/common

目录结构如下:

> - common
>   -- common.zip
>   -- unzip.cjs
>   -- index.js

zip 和 cjs 文件是刚刚的命令打包出来的

```js
// index.js
import zipped from "./common.zip?url";
import unzip from "./unzip.cjs?url";

async function load() {
  const result = await Promise.all([
    fetch(zipped).then((r) => r.arrayBuffer()),
    fetch(unzip).then((r) => r.text()),
  ]);

  return {
    zipped: result[0],
    unzip: result[1],
  };
}

export const ready = load();
```

- 最上面的两行代码使用了带有查询参数的模块导入语法，查询参数 ?url 指示构建工具如(vite)将资源文件（例如 common.zip 和 unzip.cjs）作为 URL 导入，而不是将它们的内容直接作为字符串导入。

- arrayBuffer 和 text 方法：fetch 返回一个 Response 对象。arrayBuffer 方法将响应体解析为一个 ArrayBuffer（用于处理二进制数据），而 text 方法将响应解析为一个字符串。

## client/adapters/webcontainer

对应的文件在: https://github.com/sveltejs/learn.svelte.dev/blob/main/src/lib/client/adapters/webcontainer/index.js

```js
import { WebContainer } from "@webcontainer/api";
import base64 from "base64-js";
import AnsiToHtml from "ansi-to-html";
import * as yootils from "yootils";
import { escape_html, get_depth } from "../../../utils.js";
import { ready } from "../common/index.js";
```

几个点:

- WebContainer：用于管理虚拟文件系统和执行命令。
- base64-js：用于处理 Base64 编码和解码。
- AnsiToHtml：用于将 ANSI 编码的终端输出转换为 HTML。
- yootils：包含一些实用工具函数。

### 初始化

```js
const converter = new AnsiToHtml({
  fg: "var(--sk-text-3)",
});

let vm;
```

- converter：初始化 AnsiToHtml 转换器，用于将 ANSI 编码的日志转换为 HTML。
- vm：用于存储 WebContainer 实例。

### create 函数

```js
export async function create(base, error, progress, logs, warnings) {
    progress.set({ value: 0, text: 'loading files' });

    const q = yootils.queue(1);
    const q_per_file = new Map();

    let current_stubs = stubs_to_map([]);

```

- progress：更新进度状态。
- q：初始化一个队列，用于顺序执行异步操作。
- q_per_file：存储每个文件的更新队列。
- current_stubs：存储当前加载的文件存根。

### 启动 WebContainer

这里调用了 WebContainer api, 注意该文件系统支持

```js
progress.set({ value: 1 / 5, text: "booting webcontainer" });
vm = await WebContainer.boot();

progress.set({ value: 2 / 5, text: "writing virtual files" });
const common = await ready;
await vm.mount({
  "common.zip": {
    file: { contents: new Uint8Array(common.zipped) },
  },
  "unzip.cjs": {
    file: { contents: common.unzip },
  },
});
```

WebContainer 的文件系统是支持挂在`FileSystemTree | Uint8Array | ArrayBuffer`几种类型的

```ts
 /**
     * Mounts a tree of files into the filesystem. This can be specified as a tree object ({@link FileSystemTree})
     * or as a binary snapshot generated by [`@webcontainer/snapshot`](https://www.npmjs.com/package/@webcontainer/snapshot).
     *
     * @param snapshotOrTree - A tree of files, or a binary snapshot. Note that binary payloads will be transferred.
     * @param options.mountPoint - Specifies a nested path where the tree should be mounted.
     */
    mount(snapshotOrTree: FileSystemTree | Uint8Array | ArrayBuffer, options?: {
        mountPoint?: string;
    }): Promise<void>;
```

### 处理警告和日志

```js
let $warnings;
warnings.subscribe((value) => ($warnings = value));

let timeout;
function schedule_to_update_warning(msec) {
  clearTimeout(timeout);
  timeout = setTimeout(() => warnings.set($warnings), msec);
}

const log_stream = () =>
  new WritableStream({
    write(chunk) {
      if (chunk === "\x1B[1;1H") {
        logs.set([]);
      } else if (chunk?.startsWith("svelte:warnings:")) {
        const warn = JSON.parse(chunk.slice(16));
        const current = $warnings[warn.filename];

        if (!current) {
          $warnings[warn.filename] = [warn];
        } else if (
          !current.some((s) => s.code === warn.code && s.pos === warn.pos)
        ) {
          current.push(warn);
        }

        schedule_to_update_warning(100);
      } else {
        const log = converter.toHtml(escape_html(chunk)).replace(/\n/g, "<br>");
        logs.update(($logs) => [...$logs, log]);
      }
    },
  });
```

- $warnings：存储当前的警告信息。
- schedule_to_update_warning：计划更新警告的函数。
- log_stream：处理日志流，将 ANSI 编码转换为 HTML，并更新日志状态。

### 解压和初始化

```js
progress.set({ value: 3 / 5, text: "unzipping files" });
const unzip = await vm.spawn("node", ["unzip.cjs"]);
unzip.output.pipeTo(log_stream());
const code = await unzip.exit;

if (code !== 0) {
  throw new Error("Failed to initialize WebContainer");
}

await vm.spawn("chmod", ["a+x", "node_modules/vite/bin/vite.js"]);
```

- unzip：运行解压缩脚本。
- chmod：修改 vite.js 的权限。

### 事件监听

### 返回适配器

## 参考

- https://www.youtube.com/watch?v=ePhLo_VofFg&ab_channel=LearnWithJason

## 前言

本文尝试梳理前端模块化相关的知识点，争取一文搞懂

## 为什么需要模块化

早期的 JS 没有模块化系统，所有的代码都是通过 script 的方式进行引入的

```html
<script src="lib-a-dependency.js"></script>
<script src="lib-a.js"></script>
<script src="lib-b.js"></script>
<script src="my-script.js"></script>
```

上述的方式有两个问题:

1. 命名冲突

由于代码之间会发生大量依赖与交互，如果结构不合理，不可避免地会出现命名冲突、变量污染等问题，比如上面的代码中，如果 lib-a.js 和 lib-b.js 中都定义了一个名为 `foo` 的变量，那么 my-script.js 中就无法正确访问到 lib-a.js 中的 `foo` 变量了，出了 bug 也很难排查了，

2.  文件依赖

比如 lib-a.js 依赖 lib-a-dependency.js，如果 my-script.js 的开发者忘记引入 lib-a-dependency.js，那么就会出现错误，而且这种错误很难排查，因为浏览器不会报错，只会提示 `foo is not defined`，这种问题在项目很大的时候尤其严重，因为很难保证每个开发者都能记得引入所有的依赖。

长此以往代码就会变得逐渐变为一坨大家都不愿意维护的“屎山”。

## 命名空间/闭包/IIFE

为了解决上述问题，早期的前端开发者们发明了一种利用函数作用域的模式叫做 IIFE（Immediately Invoked Function Expression）的模式,如果你仔细观察 webpack 的打包结果，你会发现 webpack 会把[所有的模块都包裹在一个 IIFE 中](https://github.com/chenxiaoyao6228/fe-notes/blob/main/Webpack/_demo/_webpack/modular/dist/main.js)

lib-a.js

```js
(function (root) {
  var foo = "bar";

  var libA = {
    foo: foo,
  };

  window.libA = libA;
})();
```

lib-a.js 文件被引入之后，会立即执行，执行的时候会创建一个函数作用域，这个函数作用域中的变量不会污染全局作用域，同时 lib-a.js 中的变量也不会被其他文件访问到，这样就解决了命名冲突的问题。

业务代码 my-script.js

```js
(function (root) {
  var a = libA.foo; // "bar"
  alert(a);
})();
```

但这种方案并没有解决文件依赖的问题，且上述只是我们简化的场景，实际开发的时候会有更多奇奇怪怪的问题，随着前端日益复杂化，模块化的解决方案迫在眉睫。

## 模块化规范的要素

在介绍 JS 中各种模块化规范之前，我们先来看看一个模块化规范需要具备哪些要素。

在模块系统中，通常会涉及到以下三个概念：模块引用、模块定义和模块标识。

- 模块定义： 模块定义指的是如何定义一个模块。在不同的模块系统中，定义模块的方式可能会有所不同。
- 模块引用： 模块引用指的是在一个模块中引用另一个模块的方式。在不同的模块系统中，模块引用的方式可能会有所不同。
- 模块标识 模块标识指的是一个字符串，用于表示模块的唯一标识符。在不同的模块系统中，模块标识的格式可能会有所不同。

以我们熟悉的 CommonJS 规范为例：

1. 模块定义: 在 CommonJS 模块系统中，使用 module.exports 对象来导出模块。例如：

```js
// lib-a.js
var foo = "foo";
module.exports = {
  foo,
};
```

2.模块引用: 在 CommonJS 模块系统中，使用 require() 函数来引入一个模块。例如:

```js
const libA = require("./lib-a");

console.log(libA.foo); // "foo"
```

3. 模块标识

在 CommonJS 模块系统中，模块标识可以是相对路径或绝对路径。例如：

```js
const myModule = require("myModule");
```

同时需要注意的是，每种模块化规范社区都有不少的实现，比如 CommonJS 有 Node.js，AMD 有 RequireJS，ES Module 有 webpack 等等，这些实现之间也有一些差异，但是他们都遵循了各自的模块化规范。

## AMD 与 RequireJS

一个常规的 requireJS 项目结构如下：

```
project-directory/
|-- index.html
|-- scripts/
| |-- lib-a.js
| |-- my-script.js
```

index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RequireJS项目展示</title>
    <!-- 引入 RequireJS -->
    <script src="https://requirejs.org/docs/release/2.3.6/minified/require.js"></script>

    <!-- 引入配置和入口脚本 -->
    <script>
      require.config({
        baseUrl: "scripts", // 设置基准路径
        paths: {
          "lib-a": "lib-a", // 不需要写.js后缀
          "my-script": "my-script",
        },
      });

      // 启动应用
      require(["my-script"]);
    </script>
  </head>
  <body></body>
</html>
```

my-script.js

```js
define(["lib-a"], function (libA) {
  var a = libA.foo; // "bar"
  alert(a);
});
```

lib-a.js

```js
define([], function () {
  var foo = "bar";

  var libA = {
    foo: foo,
  };

  return libA;
});
```

实现 amd 的一些知识点

- script 的 onload 回调后于 script 内容的执行
- 相互递归的设计
- 先别考虑怎么实现 require 和 define，先考虑 Module 应该拥有哪些状态

## CMD 与 SeaJS

## UMD

UMD 的全称是 Universal Module Definition，即通用模块定义，旨在让你的模块能在 javascript 所有运行环境中发挥作用。

这也就意味着，一个使用 UMD 规范导出的 模块既可以通过 AMD(requireJS) 的方式引入，也可以通过 CommonJS(SeaJS) 的方式引入。

```js
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    // AMD环境
    define(["dependencies"], factory);
  } else if (typeof exports === "object") {
    // Node.js环境
    module.exports = factory(require("dependencies"));
  } else {
    // 暴露到全局对象
    root.MyModule = factory(root.Dependencies);
  }
})(typeof self !== "undefined" ? self : this, function (Dependencies) {
  // 将你的代码包裹在这个闭包中
  return {
    // 暴露模块的公共接口
  };
});
```

## Webpack

Webpack 默认输出 UMD 格式，的配置中使用 output.libraryTarget 选项,可以指定打包结果中的模块化规范, 包括以下几种：

- var: 将结果通过 var 方式导出，通过 var 指定导出的变量名
- this: 将结果通过 this 方式导出
- commonjs: 将结果通过 commonjs 方式导出
- commonjs2: 将结果通过 commonjs2 方式导出
- amd: 将结果通过 amd 方式导出
- umd: 将结果通过 umd 方式导出

## require 和 import 的区别

- require 支持 **动态导入**，import 不支持，正在提案（babel 下可使用）

- require 是 **同步** 导入，import 属于 **异步** 导入

- require 是 **值拷贝**，导出值变化不会影响导入值；import 指向 **内存地址**，导入值会随导出值变化而变化
